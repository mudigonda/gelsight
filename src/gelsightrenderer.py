# Compatibility Python 2/3
from __future__ import division, print_function, absolute_import
from builtins import range
# ----------------------------------------------------------------------------------------------------------------------

import numpy as np
from dotmap import DotMap
import matplotlib.pyplot as plt
from PIL import Image
from scipy.stats import multivariate_normal

# OpenGL imports for python
try:
    from OpenGL.GL import *
    from OpenGL.GLU import *
    from OpenGL.GLUT import *
except:
    print("OpenGL wrapper for python not found")


__author__ = "Roberto Calandra"
__version__ = "0.1.0"


class GelSightRender:
    """
    GelSight Renderer
    This renderer takes as input a depth image and render the corresponding RGB image as if generated by a GelSight
    sensor.
    The rendering is not currently perfect, but it is good enough.
    """

    def __init__(self, parameters=DotMap()):
        """

        """
        self.resolutionOutput = parameters.get('resolutionOutput', [256, 256])  # Resolution of the output RGB image
        self.resolutionInput = parameters.get('resolutionInput', [100, 100])  # Resolution of the input DepthMap
        self.depthmapClip = 0.5  # Maximum deformation of the gel
        self.gelBasePos = 1
        self.gelCurvature = parameters.get('gelCurvature', True)
        self.gelCurvatureMax = 0.9  # deformation of the gel due to convexity
        self.gelCurvatureCov = 1
        self.markers = parameters.get('markers', False)  #

        # Position Camera
        self.camera = DotMap()
        self.camera.pos = [4, 0, 0]

        # Position and intensity of the lights
        self.radius = 1.5
        self.z_lights = 4
        self.intensity = 0.8
        self.lights = [DotMap(), DotMap(), DotMap()]
        self.lights[0].angle = 0
        self.lights[0].direction = [self.z_lights, self.radius*np.sin(self.lights[0].angle), self.radius*np.cos(self.lights[0].angle), self.intensity]
        self.lights[0].rgba = [0.0, 0.0, 1.0, 1.0]
        self.lights[1].angle = 2*np.pi*1/3
        self.lights[1].direction = [self.z_lights, self.radius*np.sin(self.lights[1].angle), self.radius*np.cos(self.lights[1].angle), self.intensity]
        self.lights[1].rgba = [0.0, 1.0, 0.0, 1.0]
        self.lights[2].angle = 2*np.pi*2/3
        self.lights[2].direction = [self.z_lights, self.radius*np.sin(self.lights[2].angle), self.radius*np.cos(self.lights[2].angle), self.intensity]
        self.lights[2].rgba = [1.0, 0.0, 0.0, 1.0]

        # Intensity of ambient light
        self.ambient_intensity = [0.1, 0.1, 0.1, 0.0]
        self.surface = GL_SMOOTH  # The surface type(Flat or Smooth)
        self.surface_color = [0.7, 0.7, 0.7]

        self._window = None

        self.init()

    def init(self):
        """
        Initialize rendering
        :return:
        """
        print("Calling init")
        glutInit(sys.argv)  # Initialize the OpenGL pipeline
        glutInitDisplayMode(GLUT_RGB | GLUT_DOUBLE | GLUT_DEPTH)  # Set OpenGL display mode
        # Set the Window size and position
        glutInitWindowSize(self.resolutionOutput[0], self.resolutionOutput[1])
        glutInitWindowPosition(50, 100)
        self._window = glutCreateWindow('GelSight Renderer')  # Create the window with given title

        # Set background color to black
        glClearColor(0.0, 0.0, 0.0, 0.0)

        d = np.sqrt(self.camera.pos[0]*self.camera.pos[0] +
                 self.camera.pos[1]*self.camera.pos[1] +
                 self.camera.pos[2]*self.camera.pos[2])

        # Set matrix mode
        glMatrixMode(GL_PROJECTION)

        # Reset matrix
        glLoadIdentity()
        glFrustum(-d * 0.5, d * 0.5, -d * 0.5, d * 0.5, d - 1.0, d + 1.0)

        # Set camera
        gluLookAt(self.camera.pos[0], self.camera.pos[1], self.camera.pos[2], 0, 0, 0, 0, 0, 1)

        # Set OpenGL parameters
        glEnable(GL_DEPTH_TEST)

        # Enable lighting
        glEnable(GL_LIGHTING)

        # Set light model
        glLightModelfv(GL_LIGHT_MODEL_AMBIENT, self.ambient_intensity)

        # Enable light number 0
        glEnable(GL_LIGHT0)
        glLightfv(GL_LIGHT0, GL_POSITION, self.lights[0].direction)
        glLightfv(GL_LIGHT0, GL_DIFFUSE, self.lights[0].rgba)
        # Enable light number 1
        glEnable(GL_LIGHT1)
        glLightfv(GL_LIGHT1, GL_POSITION, self.lights[1].direction)
        glLightfv(GL_LIGHT1, GL_DIFFUSE, self.lights[1].rgba)
        # Enable light number 2
        glEnable(GL_LIGHT2)
        glLightfv(GL_LIGHT2, GL_POSITION, self.lights[2].direction)
        glLightfv(GL_LIGHT2, GL_DIFFUSE, self.lights[2].rgba)

        # Setup the material
        glEnable(GL_COLOR_MATERIAL)
        glColorMaterial(GL_FRONT, GL_AMBIENT_AND_DIFFUSE)

    def extractImage(self):
        """
        Extract the pixels from the window
        :return:
        """
        buffer = (GLubyte * (3 * self.resolutionOutput[0] * self.resolutionOutput[1]))(0)
        glReadPixels(0, 0, self.resolutionOutput[0], self.resolutionOutput[1], GL_RGB, GL_UNSIGNED_BYTE, buffer)
        print("glReadPixels")
        # Use PIL to convert raw RGB buffer and flip the right way up
        image = Image.frombytes(mode="RGB", size=(self.resolutionOutput[0], self.resolutionOutput[1]), data=buffer)
        print("PIL frombytes")
        image = image.transpose(Image.FLIP_TOP_BOTTOM)
        print("PIL transpose")
        return image

    def extractRGB(self):
        """
        Return an RGB numpy array of the current window
        :return:
        """
        return np.array(self.extractImage())

    def save2file(self, nameFile):
        """
        Save the OpenGL buffer to file
        :param nameFile:
        :return:
        """
        image = self.extractImage()
        image.save(nameFile)  # Save image to disk

    def draw(self, depthmap=None):
        """
        Draw the surface
        :param depthmap: array [x,y] in [0, 255]
        :return:
        """
        depthmap = np.flipud(depthmap)  # Important. I guess that we are plotting upside-down?
        x = np.linspace(-2, 2, num=self.resolutionInput[0]+2)
        y = np.linspace(-2, 2, num=self.resolutionInput[1]+2)
        # TODO: Add markers to the surface
        # Make gel
        z = self.gelBasePos*np.ones((self.resolutionInput[0]+2, self.resolutionInput[1]+2))  # Rest position of the surface
        # Add curvature to the gel surface
        x_grid = np.linspace(-2, 2, num=self.resolutionInput[0])
        y_grid = np.linspace(-2, 2, num=self.resolutionInput[1])
        xv, yv = np.meshgrid(x_grid, y_grid)
        curvature = multivariate_normal.pdf(np.stack((xv, yv), axis=2), mean=[0, 0], cov=self.gelCurvatureCov)
        z[1:-1, 1:-1] = z[1:-1, 1:-1] - self.gelCurvatureMax * curvature/curvature.max()
        # Add normalized depthmap
        contact = self.depthmapClip * depthmap/256
        z[1:-1, 1:-1] = np.clip(z[1:-1, 1:-1] + contact, self.gelBasePos-self.gelCurvatureMax, self.gelBasePos)

        for j in range(z.shape[0]-1):
            glBegin(GL_QUAD_STRIP)  # Begin a strip
            for i in range(z.shape[1]):
                glNormal3f(z[i, j], x[j],  y[i])
                glVertex3f(z[i, j], x[j],  y[i])
                glNormal3f(z[i, j+1], x[j+1], y[i])
                glVertex3f(z[i, j+1], x[j+1], y[i])
            glEnd()  # End of the strip

    def render(self, depthmap):
        """
        Render a depthmap as a GelSight contact
        :param depthmap:
        :return:
            numpy array with the RGB image of gel having size [self.resolutionOutput[0], self.resolutionOutput[1], 3]
        """
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)
        print("glClear")
        glColor3f(self.surface_color[0], self.surface_color[1], self.surface_color[2])  # Set color Gel
        print("glColor")
        glShadeModel(self.surface)  # Set shade model
        print("glShadeModel")
        self.draw(depthmap)
        print("depthMap")
        glutSwapBuffers()
        print("SwapBuffers")
        RGB = self.extractRGB()
        print("Extract RGB")
        return RGB

    def close(self):
        """
        Close rendering
        :return:
        """
        # TODO: This is not working. Why?
        glutDestroyWindow(self._window)
        self._window = None
        # super(GelSightRender, self).close()


if __name__ == '__main__':

    p = DotMap()
    p.resolutionOutput = [100, 100]
    a = GelSightRender()  # initialize renderer

    # -----------------------

    depthmap = np.zeros((p.resolutionOutput[0], p.resolutionOutput[1]))

    plt.figure()
    plt.ion()
    plt.imshow(depthmap)
    plt.show()

    rgb_groundtruth = a.render(depthmap=depthmap)
    a.save2file(nameFile='test_00.png')

    plt.figure()
    plt.imshow(rgb_groundtruth)
    plt.show()

    # -----------------------

    # Generate test depthmap
    xyz = [0.7, 0.3]  # move to xy coordinates [-1,+1]
    x = np.linspace(-1, 1, p.resolutionOutput[0])
    y = np.linspace(-1, 1, p.resolutionOutput[1])
    xv, yv = np.meshgrid(x, y)
    pressure = 12
    depthmap = multivariate_normal.pdf(np.stack((xv, yv), axis=2), mean=xyz, cov=0.3)  # Gaussian
    depthmap = depthmap * 200 / depthmap.max()
    depthmap = np.uint8(np.maximum(np.minimum(depthmap, 255), 0))

    plt.figure()
    plt.imshow(depthmap)

    rgb = a.render(depthmap=depthmap)
    a.save2file(nameFile='test_01.png')

    plt.figure()
    plt.imshow(np.sum(rgb_groundtruth-rgb, axis=2))
    plt.show()

    # -----------------------

    resolutionOutput = [100, 100]
    depthmap = np.random.uniform(0, 100, (p.resolutionOutput[0], p.resolutionOutput[1]))

    plt.figure()
    plt.imshow(depthmap)

    rgb = a.render(depthmap=depthmap)
    a.save2file(nameFile='test_02.png')

    plt.figure()
    plt.imshow(np.sum(rgb_groundtruth-rgb, axis=2))
    plt.show()

    # -----------------------

    a.close()
    print('Done')
